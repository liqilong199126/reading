# 创建高性能的索引
索引（在`MySQL`中也叫做`键(key)`）是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。

索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急剧下降。

索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引要好两个数量级。创建一个真正的“最优”的索引经常需要重写查询。

## 索引基础
在`MySQL`中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

```sql
select first_name from sakila.actor where actor_id = 5;
```

如果在`actor_id`列上建有索引，则`MySQL`将使用该索引找到`actor_id`为`5`的行，就是说，`MySQL`先在索引上按值进行查找，然后返回所有包含该值的数据行。

索引可以包含一个或者多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为`MySQL`只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建只包含一列的索引是大不相同的。

> 注意，即使使用ORM，仍然需要理解索引。

### 索引的类型
索引有多种类型，可以为不同的场景提供更好的性能。在`MySQL`中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

#### B-Tree索引
大多数`MySQL`引擎都支持`B-Tree索引`，它使用`B-Tree`这种数据结构来存储数据。

但是，底层的存储引擎也可能使用不同的存储结构，例如，`NDB`集群存储引擎内部实际使用了`T-Tree`结构存储这种索引；`InnoDB`则使用`B+Tree`。

`B-Tree`通常意味着所有的值都是按顺序存储的，并且每个叶子页到根的距离相同。

![](http://oczira72b.bkt.clouddn.com/17-10-15/5247451.jpg)

`B-Tree`索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。

由于`B-Tree`对索引列是顺序组织存储的，所以很适合查找范围数据。

假设有下列数据表：

```sql
create table People (
  last_name  varchar(50)  not null,
  first_name  varchar(50)  not null,
  dob  date  not null,
  gender  enum('m', 'f')  not null,
  key(last_name, first_name, dob)
);
```

则对于表中的每一行数据，索引中包含了`last_name`、`first_name`、`dob`列的值。

![](http://oczira72b.bkt.clouddn.com/17-10-15/84257066.jpg)

> 注意，索引对多个值排序是create table 语句中定义索引时列的顺序。

因为索引树中的节点是有序的，所以除了按值查找以外，索引还可以用于查询中的`order by`操作（按顺序查找）。一般来说，如果`B-Tree`可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以，如果`order by`子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。

下面是关于`B-Tree`索引的限制：

* 按序索引的重要性：如果不是按照索引的最左列开始查找，则无法使用索引。例如上述`sql`，无法用于查找名字为`bill`的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。
* 不能跳过索引中的列：例如上述`sql`，无法用于查找姓为`smith`并且在某个特定日期出生的人。如果不指定`first_name`字段，则`MySQL`只能用到第一列索引。
* 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询`where last_name = 'smith' and first_name like 'J%' and dob = '1976-12-23'`，这个查询只能使用索引的前两列，因为这里的`like`是一个范围条件（但是跟服务器可以把其余列用于其他目的）。如果范围查询列值数量有限，那么可以通过**使用多个等于等于条件来代替范围条件**。

所以，索引列的顺序还是很重要的，而上述限制，都与索引列的顺序有关。

#### 哈希索引
哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

在`MySQL`中，只有`Memory`引擎显式支持哈希索引。

```sql
create table testhash (
  fname  varchar(50)  not null,
  lname  varchar(50)  not null,
  key  using  hash(fname)
) ENGINE = MEMORY;
```

假设索引中使用假想的哈希函数`f()`，它返回下面的值（均为示例数据，非真实数据）：

```
f('Arjen') = 2323
f('Baron') = 7437
f('Peter') = 8784
f('Vadim') = 2458
```

则哈希索引的数据结构如下：

| 槽（Slot） | 值（Value） |
| ------| ------ |
| 2323 | 指向第1行的指针 |
| 2458 | 指向第4行的指针 |
| 7437 | 指向第2行的指针 |
| 8784 | 指向第3行的指针 |

有了哈希索引后明显可加快单行查询速度。

但是哈希索引也有它自己的限制：

* 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。
* 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
* 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列`(A, B)`上建立哈希索引，如果查询只有数据列`A`，则无法使用该索引。
* 哈希索引只支持等值比较查询，包括`=`、`in()`、`<=>`。不支持任何范围查询，例如`where price > 100`。
* 访问哈希索引的数据非常快，除非有很多哈希冲突。
* 如果哈希冲突很多的话，一些索引维护操作的代价也很高。

哈希索引只适用于某些特定的场合。而一旦使用哈希索引，带来的性能提升非常显著。

`InnoDB`引擎有一个特殊的功能是**自适应哈希索引**，它会在内存中基于`B-Tree`索引之上再创建一个哈希索引，这样就让`B-Tree`索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全**自动的**，**内部的**行为，用户无法控制或者配置。

#### 空间数据索引（R-Tree）
`MyISAM`表支持空间索引，可以用作地理数据存储。

#### 全文索引
全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。

### 索引优点
最常见的`B-Tree`索引，按照顺序存储数据，所以`MySQL`可以用来做`order by`和`group by`操作。

三个优点：

* 索引大大减少了服务器需要扫描的数据量。
* 索引可以帮助服务器避免排序和临时表。
* 索引可以将随机`I/O`变为顺序`I/O`。

### 高性能的索引策略
正确地创建和使用索引是实现高性能查询的基础。使用哪个索引，以及如何评估选择不同索引的性能影响的技巧，则需要不断地学习。

#### 独立的列
我们通常会看到一些查询不当地使用索引，或者使得`MySQL`无法使用已有的索引。如果查询中的列不是独立的，则`MySQL`就不会使用索引。**独立的列**是指索引列不能是表达式的一部分，也不能是函数的参数。

```sql
select actor_id from sakila.actor where actor_id + 1 = 5;
```

可以看到上述的`where`表达式其实对应的是`actor_id = 4`，但是`MySQL`无法自动解析这个表达式。这完全是用户行为。我们应该养成简化`where`条件的习惯，始终将索引列单独放在比较符号的一侧。

下列是另一个常见的错误：

```sql
select ... where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

#### 前缀索引和索引选择性
前缀索引通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指，不重复的索引值（也称为基数，`cardinality`）和数据表的记录总数（`#T`）的比值，索引的选择性越高则查询效率越高。

一般情况下某个列的前缀的选择性也是足够高的，足以满足查询性能。对于`blob`、`text`或者很长的`varchar`类型的列，必须使用前缀索引，因为`MySQL`不允许这些列的完整长度。

诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节省空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。

选择合适长度的前缀索引，既可以节省空间又可以提升性能。

注意：

> 1. MySQL无法使用前缀索引做order by 和 group by，也无法使用前缀索引做覆盖扫描
> 2. 有时候后缀索引也有用途。MySQL原生并不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。可以通过触发器维护后缀索引。

#### 多列索引
很多人对于多列索引的理解都不够。一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。

```sql
create table t (
  c1  int,
  c2  int,
  c3  int,
  key(c1),
  key(c2),
  key(c3)
);
```

在多个列上建立独立的单列索引大部分情况下并不能提高`MySQL`的查询性能。`MySQL 5.0`和更新版本引入了一种叫做**“索引合并”（index merge）**的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。

例如，在表`film_actor`中的两个字段`film_id`和`actor_id`上各有一个单列索引。但对于下面这个查询`where`条件，这两个单列索引都不是最好的选择：

```sql
select film_id, actor_id from sakila.film_actor where actor_id = 1 or film_id = 1;
```

在老的`MySQL`版本中，`MySQL`对这个查询会使用全表扫描。除非改写成如下的两个查询`union`的方式：

```sql
select film_id, actor_id from sakila.film_actor where actor_id = 1
union all
select film_id, actor_id from sakila.film_actor where film_id = 1 and actor_id <> 1;
```

`MySQL`会使用这种技术优化复杂查询，所以在某些语句的`extra`列中还可以看到嵌套操作。

索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建得很糟糕：

* 当出现服务器对多个索引做相交操作时（通常有多个`and`条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
* 当服务器需要对多个索引做联合操作时（通常有多个`or`条件），通常需要耗费大量`CPU`和内存资源在算法的缓存、排序和合并操作上。
* 通常情况下，把查询写成`union`的方式会更好，特别是在`MySQL`早期版本中。

#### 选择合适的索引列顺序
索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的`order by`、`group by`和`distinct`等子句的查询需求。

> 一般情况下的经验法则：将选择性最高的列放到索引最前列。

尽管关于选择性和基数的经验法则值得去研究和分析，但一定要记住别忘了`where`子句中的排序、分组和范围条件等其他因素，这些因素可能对查询的性能产生非常大的影响。

#### 聚簇索引
聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式。但`InnoDB`的聚簇索引实际上在同一个结构中保存了`B-Tree索引`和数据行。

当表中有聚簇索引时，它的数据行实际上存放在索引的叶子页。术语`聚簇`表示数据行和相邻的键值紧凑地存储在一起。

因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。这里主要讨论`InnoDB`引擎的聚簇索引。

如下图，叶子页包含了行的全部数据，但是节点页只包含了索引列。在这个案例中，索引列包含的是整数值。

![](http://oczira72b.bkt.clouddn.com/17-10-17/96573564.jpg)

> 注意：InnoDB一般情况下通过主键聚集数据，如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键作为聚簇索引。

聚集的数据有一些重要的优点：

* 可以把相关的数据保存在一起。
* 数据访问更快。
* 使用覆盖索引扫描的查询可以直接使用页节点的主键值。

虽然在设计表和查询时能充分利用上面的优点，那就能极大地提升性能。但同时，聚簇索引也有一些缺点：

* 聚簇索引最大限度地提高了`I/O`密集型应用的性能，但如果数据全部都放到内存中，则访问的顺序就没那么重要了。
* 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到`InnoDB`表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用`optimize table`命令重新组织一下表。
* 更新聚簇索引的代价很高，因为会强制`InnoDB`将每个被更新的行移动到新的位置。
* 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临`页分裂（page split）`的问题。页分裂是指当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂将导致表会占用更多的磁盘空间。
* 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。
* 二级索引（非聚簇索引）可能比想象中更大，尽量避免二级索引。其需要两次索引查找，非一次。

##### InnoDB和MyISAM的数据分布对比
聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别。

看下列表：

```sql
create table layout_test (
  col1  int not null,
  col2  int not null,
  primary key(col1),
  key(col2)
)
```

对于`MyISAM`，其数据分布十分简单，按照数据插入顺序存储在磁盘上。上述表的具体分布如图所示：

![](http://oczira72b.bkt.clouddn.com/17-10-17/15238141.jpg)

而对于`InnoDB`支持聚簇索引，所以使用非常不同的方式存储同样的数据。

![](http://oczira72b.bkt.clouddn.com/17-10-17/13039493.jpg)

在`InnoDB`中，聚簇索引就是整个表。不像`MyISAM`那样需要独立的行存储。

聚簇索引的每一个叶子节点都包含了`主键值`、`事务ID`、`用于事务和MVCC的回滚指针`以及`所有剩余列`。

还有一点与`MyISAM`的不同是，`InnoDB`的二级索引和聚簇索引很不相同，`InnoDB`二级索引的叶子节点存储的不是**行指针**，而是**主键值**。这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作。

![](http://oczira72b.bkt.clouddn.com/17-10-17/10791546.jpg)

> 注意：避免使用随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于I/O密集型的应用。而一般使用自增列AUTO_INCREMENT作主键。因为，从性能的角度考虑，使用随机列作为聚簇索引则会很糟糕：它使得聚簇索引的插入变得完全随机，导致主键过长，页分裂和碎片，使得索引占据的空间增大，查询效率下降。因此，使用InnoDB时应该尽可能地按主键顺序插入数据，并且尽可能地使用单调增加的聚簇键的值来插入新行。
