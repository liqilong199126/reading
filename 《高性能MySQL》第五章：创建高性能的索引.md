# 创建高性能的索引
索引（在`MySQL`中也叫做`键(key)`）是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。

索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急剧下降。

索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引要好两个数量级。创建一个真正的“最优”的索引经常需要重写查询。

## 索引基础
在`MySQL`中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

```sql
select first_name from sakila.actor where actor_id = 5;
```

如果在`actor_id`列上建有索引，则`MySQL`将使用该索引找到`actor_id`为`5`的行，就是说，`MySQL`先在索引上按值进行查找，然后返回所有包含该值的数据行。

索引可以包含一个或者多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为`MySQL`只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建只包含一列的索引是大不相同的。

> 注意，即使使用ORM，仍然需要理解索引。

### 索引的类型
索引有多种类型，可以为不同的场景提供更好的性能。在`MySQL`中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

#### B-Tree索引
大多数`MySQL`引擎都支持`B-Tree索引`，它使用`B-Tree`这种数据结构来存储数据。

但是，底层的存储引擎也可能使用不同的存储结构，例如，`NDB`集群存储引擎内部实际使用了`T-Tree`结构存储这种索引；`InnoDB`则使用`B+Tree`。

`B-Tree`通常意味着所有的值都是按顺序存储的，并且每个叶子页到根的距离相同。

![](http://oczira72b.bkt.clouddn.com/17-10-15/5247451.jpg)

`B-Tree`索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。

由于`B-Tree`对索引列是顺序组织存储的，所以很适合查找范围数据。

假设有下列数据表：

```sql
create table People (
  last_name  varchar(50)  not null,
  first_name  varchar(50)  not null,
  dob  date  not null,
  gender  enum('m', 'f')  not null,
  key(last_name, first_name, dob)
);
```

则对于表中的每一行数据，索引中包含了`last_name`、`first_name`、`dob`列的值。

![](http://oczira72b.bkt.clouddn.com/17-10-15/84257066.jpg)

> 注意，索引对多个值排序是create table 语句中定义索引时列的顺序。

因为索引树中的节点是有序的，所以除了按值查找以外，索引还可以用于查询中的`order by`操作（按顺序查找）。一般来说，如果`B-Tree`可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以，如果`order by`子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。

下面是关于`B-Tree`索引的限制：

* 按序索引的重要性：如果不是按照索引的最左列开始查找，则无法使用索引。例如上述`sql`，无法用于查找名字为`bill`的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。
* 不能跳过索引中的列：例如上述`sql`，无法用于查找姓为`smith`并且在某个特定日期出生的人。如果不指定`first_name`字段，则`MySQL`只能用到第一列索引。
* 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询`where last_name = 'smith' and first_name like 'J%' and dob = '1976-12-23'`，这个查询只能使用索引的前两列，因为这里的`like`是一个范围条件（但是跟服务器可以把其余列用于其他目的）。如果范围查询列值数量有限，那么可以通过**使用多个等于等于条件来代替范围条件**。

所以，索引列的顺序还是很重要的，而上述限制，都与索引列的顺序有关。

#### 哈希索引
哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

在`MySQL`中，只有`Memory`引擎显式支持哈希索引。

```sql
create table testhash (
  fname  varchar(50)  not null,
  lname  varchar(50)  not null,
  key  using  hash(fname)
) ENGINE = MEMORY;
```

假设索引中使用假想的哈希函数`f()`，它返回下面的值（均为示例数据，非真实数据）：

```
f('Arjen') = 2323
f('Baron') = 7437
f('Peter') = 8784
f('Vadim') = 2458
```

则哈希索引的数据结构如下：

| 槽（Slot） | 值（Value） |
| ------| ------ |
| 2323 | 指向第1行的指针 |
| 2458 | 指向第4行的指针 |
| 7437 | 指向第2行的指针 |
| 8784 | 指向第3行的指针 |

有了哈希索引后明显可加快单行查询速度。

但是哈希索引也有它自己的限制：

* 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。
* 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
* 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列`(A, B)`上建立哈希索引，如果查询只有数据列`A`，则无法使用该索引。
* 哈希索引只支持等值比较查询，包括`=`、`in()`、`<=>`。不支持任何范围查询，例如`where price > 100`。
* 访问哈希索引的数据非常快，除非有很多哈希冲突。
* 如果哈希冲突很多的话，一些索引维护操作的代价也很高。

哈希索引只适用于某些特定的场合。而一旦使用哈希索引，带来的性能提升非常显著。

`InnoDB`引擎有一个特殊的功能是**自适应哈希索引**，它会在内存中基于`B-Tree`索引之上再创建一个哈希索引，这样就让`B-Tree`索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全**自动的**，**内部的**行为，用户无法控制或者配置。

#### 空间数据索引（R-Tree）
`MyISAM`表支持空间索引，可以用作地理数据存储。

#### 全文索引
全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。

### 索引优点
最常见的`B-Tree`索引，按照顺序存储数据，所以`MySQL`可以用来做`order by`和`group by`操作。

三个优点：

* 索引大大减少了服务器需要扫描的数据量。
* 索引可以帮助服务器避免排序和临时表。
* 索引可以将随机`I/O`变为顺序`I/O`。

### 高性能的索引策略
正确地创建和使用索引是实现高性能查询的基础。使用哪个索引，以及如何评估选择不同索引的性能影响的技巧，则需要不断地学习。

#### 独立的列
我们通常会看到一些查询不当地使用索引，或者使得`MySQL`无法使用已有的索引。如果查询中的列不是独立的，则`MySQL`就不会使用索引。**独立的列**是指索引列不能是表达式的一部分，也不能是函数的参数。

```sql
select actor_id from sakila.actor where actor_id + 1 = 5;
```

可以看到上述的`where`表达式其实对应的是`actor_id = 4`，但是`MySQL`无法自动解析这个表达式。这完全是用户行为。我们应该养成简化`where`条件的习惯，始终将索引列单独放在比较符号的一侧。

下列是另一个常见的错误：

```sql
select ... where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

#### 前缀索引和索引选择性
前缀索引通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指，不重复的索引值（也称为基数，`cardinality`）和数据表的记录总数（`#T`）的比值，索引的选择性越高则查询效率越高。

一般情况下某个列的前缀的选择性也是足够高的，足以满足查询性能。对于`blob`、`text`或者很长的`varchar`类型的列，必须使用前缀索引，因为`MySQL`不允许这些列的完整长度。

诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节省空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。

选择合适长度的前缀索引，既可以节省空间又可以提升性能。

注意：

> 1. MySQL无法使用前缀索引做order by 和 group by，也无法使用前缀索引做覆盖扫描
> 2. 有时候后缀索引也有用途。MySQL原生并不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。可以通过触发器维护后缀索引。

#### 多列索引
