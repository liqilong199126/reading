# 聚合数据模型
`数据模型`一般是指应用程序的特定数据所具备的模型，对于开发者而言，可能会指一张数据库的的`实体 - 关系图(entity-relationship diagram)`。然而本书中的`数据模型`通常表示数据库组织数据的方式，它的正式名称是`元模型`。

`表`又可称为`关系`，`行`又可称为`元组`。

`NoSQL`与传统的关系型数据库相比，一个最明显的转变就是抛弃了关系模型。

`NoSQL`生态系统中广泛使用的模型有以下四类：

* 键值数据库
* 文档数据库
* 列族数据库
* 图数据库

其中前三类数据库有一个共同特征，称为`面向聚合(aggregate orientation)`。

## 聚合
关系模型把待存储的信息分隔成元组（行）。元组是种是种首先的数据结构：它只能包含一系列的值，因此不能在元组中嵌套另一个元组，也不能包含由值或元组所组成的列表。

面向聚合所用的方式与之不同，我们通常操作数据时所用的单元，其结构都比元组集合复杂得多。如果能够以这种复杂的结构来存放列表或嵌套其他记录结构就好了。`键值数据库`、`文档数据库`、`列族数据库`都使用这种更为复杂的记录。一般把这种结构称为`聚合(aggregate)`。

一般情况下，我们通过`原子操作(atomic operation)`更新聚合的值，并且在与数据存储通信时，也以聚合为单位。

### 关系模型和聚合模型示例
一个电子商务网站，把商品通过网站卖给消费者，需要存储用户信息、商品目录、订单、收货地址、账单地址和付款方式等信息。使用关系模型，每张表不会出现重复数据，维护了表格间的`参照完整性`。如下图所示：

![](http://oczira72b.bkt.clouddn.com/17-10-29/3399438.jpg)

如果使用面向聚合的思想来做，如图所示：

![](http://oczira72b.bkt.clouddn.com/17-10-29/68750917.jpg)

使用`JSON`格式来表示：

```json
// in customers
{
  "id": 1,
  "name": "Martin",
  "billingAddress": [
    {
      "city": "Chicago"
    }
  ]
}

// in orders
{
  "id": 99,
  "customerId": 1,
  "orderItems": [
    {
      "productId": 27,
      "price": 32.45,
      "productName": "NoSQL Distilled"
    }
  ],
  "shippingAddress": [
    {
      "city": "Chicago"
    }
  ],
  "orderPayment": [
    {
      "ccinfo": "1000-1000-1000-1000",
      "txnId": "abelif879rft",
      "billingAddress": {
        "city": "Chicago"
      }
    }
  ]
}
```

以下一些特点：

* 同一个逻辑地址出现了多次，如示例数据中的`"Chicago"`。
* 客户与订单之间的关联并不在某个聚合结构内部，它们算是两个聚合之间的关系。这种做法在聚合模型中更常见，因为我们希望在数据交互时尽量减少所需访问的聚合个数。

因此在上述例子中，我们可以合并聚合数目：

![](http://oczira72b.bkt.clouddn.com/17-10-29/15358822.jpg)

```json
// in customers
{
  "id": 1,
  "name": "Martin",
  "billingAddress": [
    {
      "city": "Chicago"
    }
  ],
  "orders": [
    {
      "id": 99,
      "customerId": 1,
      "orderItems": [
        {
          "productId": 27,
          "price": 32.45,
          "productName": "NoSQL Distilled"
        }
      ],
      "shippingAddress": [
        {
          "city": "Chicago"
        }
      ],
      "orderPayment": [
        {
          "ccinfo": "1000-1000-1000-1000",
          "txnId": "abelif879rft",
          "billingAddress": {
            "city": "Chicago"
          }
        }
      ]
    }
  ]
}
```

对于如何划分聚合边界并没有标准答案，这完全取决于你打算怎么来操作数据。

### 面向聚合的影响
虽然关系映射能够很好地捕捉各种数据元素及其关系，但是它却没有`聚合实体(aggregate entity)`这一概念。

如果使用面向聚合的数据库，那么通过考虑与数据存储交互时所用的单位，我们就能得出一种更为清晰的语义了。

关系型数据库的关系模型中，可以用`外键`连接，数据库无法使用聚合结构来帮助其存储和分布数据。在关系型数据库的数据模型和`NoSQL`领域的`图数据库`，他们都是`聚合无知`的。因此他们都不太容易使用集群。

选用面向聚合模型的决定性因素，就在于它非常适合在集群上运行。它适用于不同的服务器，如果在数据库中明确包含聚合结构，那么它就可以根据这一重要信息，知道哪些数据需要一起操作了，并且这些数据应该放在同一个节点中。

> 注意：通常情况下，面向聚合的数据库确实不支持跨越多个聚合的ACID事务，但取而代之的是：它每次在一个聚合结构上执行原子操作。

## 键值数据库和文档数据库
键值数据库和文档数据库都特别面向聚合，他们都主要通过聚合来构建，他们的主要区别是：

* 键值数据库的聚合不透明，只包含一些没有太多意义的大块信息，文档数据库可以看到其结构，它限制了其中存放的内容，它定义了其允许的结构与数据类型，可以灵活地访问数据
* 在键值数据库中，要访问聚合内容，只能通过键来查找。而使用文档数据库时，则可以用聚合中的字段查询。

## 列族存储
大部分数据库都以行为单元存储数据，尤其是在需要提高写入性能的场合更是如此。然而，有些情况下写入操作执行得很少，但是经常需要一次读取若干行的很多列，在这种情况下，将所有行的某一组列作为基本数据存储单元，效果会更好。

列族数据库就是两级聚合结构。与键值存储相同，第一个键通常代表行标识符，可以用它来获取想要的聚合。列族结构与键值存储的区别在于，其行聚合本身又是一个映射，其中包含一些更为详细的值。这些二级值就叫做列。列族数据库将列组织为列族，每一列都必须是某一列族的一部分，。而且访问的数据单元也是列。

![](http://oczira72b.bkt.clouddn.com/17-10-29/58518570.jpg)

于是，我们也得出了两种数据组织方式：

* `面向行(row-oriented)`：每一行都是一个聚合，该聚合内部存有一些包含有用数据块的列族。
* `面向列(column-oriented)`：每个列族都定义了一种记录类型，其中每行都表示一条记录。可以将数据库中的大行理解为列族中每一个短行记录的串接。

## 面向聚合数据库总结
包含三种数据库：

* 键值数据库
* 文档数据库
* 列族数据库

三者的共同点是，它们都使用聚合这一概念，而且聚合中都有一个可以查找其内容的索引键。在集群上运行时，聚合是中心环节，因为数据库必须保证将聚合内数据存放在同一个节点上。聚合还是更新操作的最小数据单位，对事务控制来说，以聚合为操作单元，其大小正合适。

## 要点
* 聚合是作为交互单元的数据集合。数据库中的ACID操作以聚合为界。
* 键值数据库、文档数据库、列族数据库都属于面向聚合的数据库。
* 聚合使数据库在集群上管理数据存储更为方便。
* 如果数据交互大多在同一聚合内执行，则应使用面向聚合的数据库。若交互操作需要使用多种不同格式的数据，那么最好选用聚合无知式数据库。