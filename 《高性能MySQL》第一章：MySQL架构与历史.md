# MySQL架构与历史
## MySQL的逻辑架构
![](http://oczira72b.bkt.clouddn.com/17-10-12/64415193.jpg)

MySQL的逻辑架构分三层：

1. 最上层的服务不是`MySQL`独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构，比如连接处理、授权认证、安全等
2. 第二层架构包含`MySQL`的核心服务功能，包括查询解析、分析、优化、缓存以及所有内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
3. 第三层包含了存储引擎，负责`MySQL`中数据的存储和提取。每个存储引擎有其优势和劣势，存储引擎不会解析`SQL`，不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。

### 连接管理与安全性
当客户端连接到`MySQL`服务器时，服务器需要对其认证。认证基于用户名、原始主机信息和密码。还可以使用`安全套接字（SSL）`的方式连接，一旦客户端连接成功，服务器会继续验证该客户端是否具有执行某个特定查询的权限。
### 优化和执行
`MySQL`会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。

特殊的，对于`select`语句，在解析查询之前，服务器会先检查`查询缓存（Query Cache）`，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。
## 并发控制
通过锁来进行并发控制。
### 读写锁
* 共享锁（读锁）：共享的，相互不阻塞。多个用户在同一时刻可以读取同一个资源，而互不干扰。
* 排他锁（写锁）：排他的，也就是说一个写锁会阻塞其它的写锁和读锁。

`MySQL`锁的内部管理都是透明的。
### 锁粒度
原则上尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。

* 表锁：锁定正在操作的表，开销最小的策略
* 行级锁：锁定正在操作的行，可以最大程度支持并发处理（但是同时也带来了最大的锁开销）。行级锁只在存储引擎层实现，而`MySQL`服务器层没有实现。

每种`MySQL`存储引擎都可以实现自己的锁策略和锁粒度。

## 事务
事务就是一组原子性的`SQL`查询，或者说一个独立的工作单元。在事务内的语句，要么全部执行成功，要么全部执行失败。

- 数据库的`ACID`
  - 原子性：一个事务必须视为一个不可分割的最小工作单位。
  - 一致性：数据库总是从一个一致性的状态转换到另外一个一致性的状态。
  - 隔离性：一个事务所做的修改在最终提交之前，对其他事务是不可见的。
  - 持久性：一旦事务提交，其所做的修改就会永久保存到数据库中。

### 隔离级别
- `READ UNCOMMITTED(未提交读)`：在事务中修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为“脏读”。
- `READ COMMITTED (提交读)`：大多数数据库系统的默认隔离级别都是`READ COMMITTED`（但是`MySQL`不是）。一个事务开始时，只能看见已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。
- `REPEATABLE READ（可重复读）`：保证了在同一个事务中多次读取同样记录的结果都是一致的。这个隔离级别避免了脏读，但是还是无法解决另外一个幻读的问题。所谓的幻读：指当某个事务在读取某个范围的记录时，另外一个事务又在该范围内插入新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。
- `SERIALIZABLE(可串行化)`：最高的隔离级别。通过强制事务串行执行，通过在读取的每一行数据上都加锁，避免前面的幻读问题。

### 死锁
数据库系统实现了各种死锁检测和死锁超时机制。

锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的。

死锁发生以后，只有部分或者完全回滚一个事务，才能打破死锁。对于事务型的系统，这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下，只需要重新执行因死锁回滚的事务即可。

### 事务日志
事务日志可以帮助提高事务的效率。事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘，目前大多数存储引擎都是这么实现的。
### MySQL中的事务
#### 自动提交（AUTOCOMMIT）
`MySQL`默认采用`自动提交（AUTOCOMMIT）`模式。也就是说，如果不是显式地开始一个事务，则每个查询都被当做一个事务执行提交操作。在当前连接中，可以通过设置`AUTOCOMMIT`变量来启用或者禁用自动提交模式：

```sql
mysql> show variables like 'AUTOCOMMIT';
mysql> set AUTOCOMMIT = 1;
```

同理，`MySQL`还可以通过执行`SET TRANSACTION ISOLATION LEVEL`命令来设置隔离级别。新的隔离级别会在下一个事务开始时生效。

```sql
mysql> set session transaction isolation level READ COMMITTED;
```

#### 在事务中混合使用存储引擎
`MySQL`服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。

但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。`MySQL`具有事务型（`InnoDB`）的表和非事务型（`MyISAM`）的表。

#### 隐式和显式锁定
`InnoDB`采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行`COMMIT`或者`ROLLBACK`的时候才会释放，并且所有的锁是在同一时刻被释放。

另外，`InnoDB`也支持通过特定的语句进行显式锁定，这些语句不属于`SQL规范`

* `SELECT ... LOCK IN SHARE MODE`
* `SELECT ... FOR UPDATE`

`MySQL`也支持`LOCK TABELS`和`UNLOCK TABLES`语句，这是在服务器层实现的，和存储引擎无关。如果应用需要用到事务，还是应该选择事务型存储引擎，如`InnoDB`。

## 多版本并发控制（MVCC）
`MVCC`的实现：是通过保存数据在某个时间点的快照来实现的。
